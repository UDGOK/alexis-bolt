"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel";
exports.ids = ["vendor-chunks/@vercel"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@vercel/blob/dist/chunk-KN6WT5GP.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/chunk-KN6WT5GP.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* binding */ BlobAccessError),\n/* harmony export */   BlobClientTokenExpiredError: () => (/* binding */ BlobClientTokenExpiredError),\n/* harmony export */   BlobContentTypeNotAllowedError: () => (/* binding */ BlobContentTypeNotAllowedError),\n/* harmony export */   BlobError: () => (/* binding */ BlobError),\n/* harmony export */   BlobFileTooLargeError: () => (/* binding */ BlobFileTooLargeError),\n/* harmony export */   BlobNotFoundError: () => (/* binding */ BlobNotFoundError),\n/* harmony export */   BlobPathnameMismatchError: () => (/* binding */ BlobPathnameMismatchError),\n/* harmony export */   BlobRequestAbortedError: () => (/* binding */ BlobRequestAbortedError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* binding */ BlobServiceNotAvailable),\n/* harmony export */   BlobServiceRateLimited: () => (/* binding */ BlobServiceRateLimited),\n/* harmony export */   BlobStoreNotFoundError: () => (/* binding */ BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* binding */ BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* binding */ BlobUnknownError),\n/* harmony export */   MAXIMUM_PATHNAME_LENGTH: () => (/* binding */ MAXIMUM_PATHNAME_LENGTH),\n/* harmony export */   createCompleteMultipartUploadMethod: () => (/* binding */ createCompleteMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploadMethod: () => (/* binding */ createCreateMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploaderMethod: () => (/* binding */ createCreateMultipartUploaderMethod),\n/* harmony export */   createFolder: () => (/* binding */ createFolder),\n/* harmony export */   createPutMethod: () => (/* binding */ createPutMethod),\n/* harmony export */   createUploadPartMethod: () => (/* binding */ createUploadPartMethod),\n/* harmony export */   disallowedPathnameCharacters: () => (/* binding */ disallowedPathnameCharacters),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl),\n/* harmony export */   getTokenFromOptionsOrEnv: () => (/* binding */ getTokenFromOptionsOrEnv),\n/* harmony export */   requestApi: () => (/* binding */ requestApi)\n/* harmony export */ });\n/* harmony import */ var is_node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-node-process */ \"(action-browser)/./node_modules/is-node-process/lib/index.mjs\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! is-buffer */ \"(action-browser)/./node_modules/is-buffer/index.js\");\n/* harmony import */ var async_retry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! async-retry */ \"(action-browser)/./node_modules/async-retry/lib/index.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! undici */ \"(action-browser)/./node_modules/undici/index.js\");\n/* harmony import */ var bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bytes */ \"(action-browser)/./node_modules/bytes/index.js\");\n/* harmony import */ var throttleit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! throttleit */ \"(action-browser)/./node_modules/throttleit/index.js\");\n// src/helpers.ts\n\n\n// src/multipart/helpers.ts\n\n\nvar supportsNewBlobFromArrayBuffer = new Promise((resolve) => {\n  try {\n    const helloAsArrayBuffer = new Uint8Array([104, 101, 108, 108, 111]);\n    const blob = new Blob([helloAsArrayBuffer]);\n    blob.text().then((text) => {\n      resolve(text === \"hello\");\n    }).catch(() => {\n      resolve(false);\n    });\n  } catch {\n    resolve(false);\n  }\n});\nasync function toReadableStream(value) {\n  if (value instanceof ReadableStream) {\n    return value;\n  }\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n  if (isNodeJsReadableStream(value)) {\n    return stream__WEBPACK_IMPORTED_MODULE_1__.Readable.toWeb(value);\n  }\n  let streamValue;\n  if (value instanceof ArrayBuffer) {\n    streamValue = new Uint8Array(value);\n  } else if (isNodeJsBuffer(value)) {\n    streamValue = value;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n  if (await supportsNewBlobFromArrayBuffer) {\n    return new Blob([streamValue]).stream();\n  }\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    }\n  });\n}\nfunction isNodeJsReadableStream(value) {\n  return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n  typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\nfunction isNodeJsBuffer(value) {\n  return is_buffer__WEBPACK_IMPORTED_MODULE_2__(value);\n}\n\n// src/helpers.ts\nfunction getTokenFromOptionsOrEnv(options) {\n  if (options == null ? void 0 : options.token) {\n    return options.token;\n  }\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n  throw new BlobError(\n    \"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\"\n  );\n}\nvar BlobError = class extends Error {\n  constructor(message) {\n    super(`Vercel Blob: ${message}`);\n  }\n};\nfunction getDownloadUrl(blobUrl) {\n  const url = new URL(blobUrl);\n  url.searchParams.set(\"download\", \"1\");\n  return url.toString();\n}\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\nvar disallowedPathnameCharacters = [\"#\", \"?\", \"//\"];\nvar supportsRequestStreams = (() => {\n  if ((0,is_node_process__WEBPACK_IMPORTED_MODULE_0__.isNodeProcess)()) {\n    return true;\n  }\n  let duplexAccessed = false;\n  const hasContentType = new Request(getApiUrl(), {\n    body: new ReadableStream(),\n    method: \"POST\",\n    // @ts-expect-error -- TypeScript doesn't yet have duplex but it's in the spec: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1729\n    get duplex() {\n      duplexAccessed = true;\n      return \"half\";\n    }\n  }).headers.has(\"Content-Type\");\n  return duplexAccessed && !hasContentType;\n})();\nfunction getApiUrl(pathname = \"\") {\n  let baseUrl = null;\n  try {\n    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n  }\n  return `${baseUrl || \"https://blob.vercel-storage.com\"}${pathname}`;\n}\nvar TEXT_ENCODER = typeof TextEncoder === \"function\" ? new TextEncoder() : null;\nfunction computeBodyLength(body) {\n  if (!body) {\n    return 0;\n  }\n  if (typeof body === \"string\") {\n    if (TEXT_ENCODER) {\n      return TEXT_ENCODER.encode(body).byteLength;\n    }\n    return new Blob([body]).size;\n  }\n  if (\"byteLength\" in body && typeof body.byteLength === \"number\") {\n    return body.byteLength;\n  }\n  if (\"size\" in body && typeof body.size === \"number\") {\n    return body.size;\n  }\n  return 0;\n}\nvar createChunkTransformStream = (chunkSize, onProgress) => {\n  let buffer = new Uint8Array(0);\n  return new TransformStream({\n    transform(chunk, controller) {\n      queueMicrotask(() => {\n        const newBuffer = new Uint8Array(buffer.length + chunk.byteLength);\n        newBuffer.set(buffer);\n        newBuffer.set(new Uint8Array(chunk), buffer.length);\n        buffer = newBuffer;\n        while (buffer.length >= chunkSize) {\n          const newChunk = buffer.slice(0, chunkSize);\n          controller.enqueue(newChunk);\n          onProgress == null ? void 0 : onProgress(newChunk.byteLength);\n          buffer = buffer.slice(chunkSize);\n        }\n      });\n    },\n    flush(controller) {\n      queueMicrotask(() => {\n        if (buffer.length > 0) {\n          controller.enqueue(buffer);\n          onProgress == null ? void 0 : onProgress(buffer.byteLength);\n        }\n      });\n    }\n  });\n};\nfunction isReadableStream(value) {\n  return (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Not present in Node.js 16\n    globalThis.ReadableStream && // TODO: Can be removed once Node.js 16 is no more required internally\n    value instanceof ReadableStream\n  );\n}\nfunction isStream(value) {\n  if (isReadableStream(value)) {\n    return true;\n  }\n  if (isNodeJsReadableStream(value)) {\n    return true;\n  }\n  return false;\n}\n\n// src/api.ts\n\n\n// src/is-network-error.ts\nvar objectToString = Object.prototype.toString;\nvar isError = (value) => objectToString.call(value) === \"[object Error]\";\nvar errorMessages = /* @__PURE__ */ new Set([\n  \"network error\",\n  // Chrome\n  \"Failed to fetch\",\n  // Chrome\n  \"NetworkError when attempting to fetch resource.\",\n  // Firefox\n  \"The Internet connection appears to be offline.\",\n  // Safari 16\n  \"Load failed\",\n  // Safari 17+\n  \"Network request failed\",\n  // `cross-fetch`\n  \"fetch failed\",\n  // Undici (Node.js)\n  \"terminated\"\n  // Undici (Node.js)\n]);\nfunction isNetworkError(error) {\n  const isValid = error && isError(error) && error.name === \"TypeError\" && typeof error.message === \"string\";\n  if (!isValid) {\n    return false;\n  }\n  if (error.message === \"Load failed\") {\n    return error.stack === void 0;\n  }\n  return errorMessages.has(error.message);\n}\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n  if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n    debugIsActive = true;\n  }\n} catch (error) {\n}\nfunction debug(message, ...args) {\n  if (debugIsActive) {\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n\n// src/fetch.ts\n\nvar hasFetch = typeof undici__WEBPACK_IMPORTED_MODULE_4__.fetch === \"function\";\nvar hasFetchWithUploadProgress = hasFetch && supportsRequestStreams;\nvar CHUNK_SIZE = 64 * 1024;\nvar blobFetch = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using fetch\");\n  let body;\n  if (init.body) {\n    if (onUploadProgress) {\n      const stream = await toReadableStream(init.body);\n      let loaded = 0;\n      const chunkTransformStream = createChunkTransformStream(\n        CHUNK_SIZE,\n        (newLoaded) => {\n          loaded += newLoaded;\n          onUploadProgress(loaded);\n        }\n      );\n      body = stream.pipeThrough(chunkTransformStream);\n    } else {\n      body = init.body;\n    }\n  }\n  const duplex = supportsRequestStreams && body && isStream(body) ? \"half\" : void 0;\n  return (0,undici__WEBPACK_IMPORTED_MODULE_4__.fetch)(\n    input,\n    // @ts-expect-error -- Blob and Nodejs Blob are triggering type errors, fine with it\n    {\n      ...init,\n      ...init.body ? { body } : {},\n      duplex\n    }\n  );\n};\n\n// src/xhr.ts\nvar hasXhr = typeof XMLHttpRequest !== \"undefined\";\nvar blobXhr = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using xhr\");\n  let body = null;\n  if (init.body) {\n    if (isReadableStream(init.body)) {\n      body = await new Response(init.body).blob();\n    } else {\n      body = init.body;\n    }\n  }\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(init.method || \"GET\", input.toString(), true);\n    if (onUploadProgress) {\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          onUploadProgress(event.loaded);\n        }\n      });\n    }\n    xhr.onload = () => {\n      var _a3;\n      if ((_a3 = init.signal) == null ? void 0 : _a3.aborted) {\n        reject(new DOMException(\"The user aborted the request.\", \"AbortError\"));\n        return;\n      }\n      const headers = new Headers();\n      const rawHeaders = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n      rawHeaders.forEach((line) => {\n        const parts = line.split(\": \");\n        const key = parts.shift();\n        const value = parts.join(\": \");\n        if (key) headers.set(key.toLowerCase(), value);\n      });\n      const response = new Response(xhr.response, {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers\n      });\n      resolve(response);\n    };\n    xhr.onerror = () => {\n      reject(new TypeError(\"Network request failed\"));\n    };\n    xhr.ontimeout = () => {\n      reject(new TypeError(\"Network request timed out\"));\n    };\n    xhr.onabort = () => {\n      reject(new DOMException(\"The user aborted a request.\", \"AbortError\"));\n    };\n    if (init.headers) {\n      const headers = new Headers(init.headers);\n      headers.forEach((value, key) => {\n        xhr.setRequestHeader(key, value);\n      });\n    }\n    if (init.signal) {\n      init.signal.addEventListener(\"abort\", () => {\n        xhr.abort();\n      });\n      if (init.signal.aborted) {\n        xhr.abort();\n        return;\n      }\n    }\n    xhr.send(body);\n  });\n};\n\n// src/request.ts\nvar blobRequest = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  if (onUploadProgress) {\n    if (hasFetchWithUploadProgress) {\n      return blobFetch({ input, init, onUploadProgress });\n    }\n    if (hasXhr) {\n      return blobXhr({ input, init, onUploadProgress });\n    }\n  }\n  if (hasFetch) {\n    return blobFetch({ input, init });\n  }\n  if (hasXhr) {\n    return blobXhr({ input, init });\n  }\n  throw new Error(\"No request implementation available\");\n};\n\n// src/dom-exception.ts\nvar _a2;\nvar DOMException2 = (_a2 = globalThis.DOMException) != null ? _a2 : (() => {\n  try {\n    atob(\"~\");\n  } catch (err) {\n    return Object.getPrototypeOf(err).constructor;\n  }\n})();\n\n// src/api.ts\nvar MAXIMUM_PATHNAME_LENGTH = 950;\nvar BlobAccessError = class extends BlobError {\n  constructor() {\n    super(\"Access denied, please provide a valid token for this resource.\");\n  }\n};\nvar BlobContentTypeNotAllowedError = class extends BlobError {\n  constructor(message) {\n    super(`Content type mismatch, ${message}.`);\n  }\n};\nvar BlobPathnameMismatchError = class extends BlobError {\n  constructor(message) {\n    super(\n      `Pathname mismatch, ${message}. Check the pathname used in upload() or put() matches the one from the client token.`\n    );\n  }\n};\nvar BlobClientTokenExpiredError = class extends BlobError {\n  constructor() {\n    super(\"Client token has expired.\");\n  }\n};\nvar BlobFileTooLargeError = class extends BlobError {\n  constructor(message) {\n    super(`File is too large, ${message}.`);\n  }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"This store does not exist.\");\n  }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n  constructor() {\n    super(\"This store has been suspended.\");\n  }\n};\nvar BlobUnknownError = class extends BlobError {\n  constructor() {\n    super(\"Unknown error, please visit https://vercel.com/help.\");\n  }\n};\nvar BlobNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"The requested blob does not exist\");\n  }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n  constructor() {\n    super(\"The blob service is currently not available. Please try again.\");\n  }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n  constructor(seconds) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${seconds ? ` - try again in ${seconds} seconds` : \"\"}.`\n    );\n    this.retryAfter = seconds != null ? seconds : 0;\n  }\n};\nvar BlobRequestAbortedError = class extends BlobError {\n  constructor() {\n    super(\"The request was aborted.\");\n  }\n};\nvar BLOB_API_VERSION = 8;\nfunction getApiVersion() {\n  let versionOverride = null;\n  try {\n    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n  }\n  return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;\n}\nfunction getRetries() {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\nfunction createBlobServiceRateLimited(response) {\n  const retryAfter = response.headers.get(\"retry-after\");\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : void 0\n  );\n}\nasync function getBlobError(response) {\n  var _a3, _b2, _c;\n  let code;\n  let message;\n  try {\n    const data = await response.json();\n    code = (_b2 = (_a3 = data.error) == null ? void 0 : _a3.code) != null ? _b2 : \"unknown_error\";\n    message = (_c = data.error) == null ? void 0 : _c.message;\n  } catch {\n    code = \"unknown_error\";\n  }\n  if ((message == null ? void 0 : message.includes(\"contentType\")) && message.includes(\"is not allowed\")) {\n    code = \"content_type_not_allowed\";\n  }\n  if ((message == null ? void 0 : message.includes('\"pathname\"')) && message.includes(\"does not match the token payload\")) {\n    code = \"client_token_pathname_mismatch\";\n  }\n  if (message === \"Token expired\") {\n    code = \"client_token_expired\";\n  }\n  if (message == null ? void 0 : message.includes(\"the file length cannot be greater than\")) {\n    code = \"file_too_large\";\n  }\n  let error;\n  switch (code) {\n    case \"store_suspended\":\n      error = new BlobStoreSuspendedError();\n      break;\n    case \"forbidden\":\n      error = new BlobAccessError();\n      break;\n    case \"content_type_not_allowed\":\n      error = new BlobContentTypeNotAllowedError(message);\n      break;\n    case \"client_token_pathname_mismatch\":\n      error = new BlobPathnameMismatchError(message);\n      break;\n    case \"client_token_expired\":\n      error = new BlobClientTokenExpiredError();\n      break;\n    case \"file_too_large\":\n      error = new BlobFileTooLargeError(message);\n      break;\n    case \"not_found\":\n      error = new BlobNotFoundError();\n      break;\n    case \"store_not_found\":\n      error = new BlobStoreNotFoundError();\n      break;\n    case \"bad_request\":\n      error = new BlobError(message != null ? message : \"Bad request\");\n      break;\n    case \"service_unavailable\":\n      error = new BlobServiceNotAvailable();\n      break;\n    case \"rate_limited\":\n      error = createBlobServiceRateLimited(response);\n      break;\n    case \"unknown_error\":\n    case \"not_allowed\":\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n  return { code, error };\n}\nasync function requestApi(pathname, init, commandOptions) {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n  const [, , , storeId = \"\"] = token.split(\"_\");\n  const requestId = `${storeId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;\n  let retryCount = 0;\n  let bodyLength = 0;\n  let totalLoaded = 0;\n  const sendBodyLength = (commandOptions == null ? void 0 : commandOptions.onUploadProgress) || shouldUseXContentLength();\n  if (init.body && // 1. For upload progress we always need to know the total size of the body\n  // 2. In development we need the header for put() to work correctly when passing a stream\n  sendBodyLength) {\n    bodyLength = computeBodyLength(init.body);\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: 0,\n      total: bodyLength,\n      percentage: 0\n    });\n  }\n  const apiResponse = await async_retry__WEBPACK_IMPORTED_MODULE_3__(\n    async (bail) => {\n      let res;\n      try {\n        res = await blobRequest({\n          input: getApiUrl(pathname),\n          init: {\n            ...init,\n            headers: {\n              \"x-api-blob-request-id\": requestId,\n              \"x-api-blob-request-attempt\": String(retryCount),\n              \"x-api-version\": apiVersion,\n              ...sendBodyLength ? { \"x-content-length\": String(bodyLength) } : {},\n              authorization: `Bearer ${token}`,\n              ...extraHeaders,\n              ...init.headers\n            }\n          },\n          onUploadProgress: (commandOptions == null ? void 0 : commandOptions.onUploadProgress) ? (loaded) => {\n            var _a3;\n            const total = bodyLength !== 0 ? bodyLength : loaded;\n            totalLoaded = loaded;\n            const percentage = bodyLength > 0 ? Number((loaded / total * 100).toFixed(2)) : 0;\n            if (percentage === 100 && bodyLength > 0) {\n              return;\n            }\n            (_a3 = commandOptions.onUploadProgress) == null ? void 0 : _a3.call(commandOptions, {\n              loaded,\n              // When passing a stream to put(), we have no way to know the total size of the body.\n              // Instead of defining total as total?: number we decided to set the total to the currently\n              // loaded number. This is not inaccurate and way more practical for DX.\n              // Passing down a stream to put() is very rare\n              total,\n              percentage\n            });\n          } : void 0\n        });\n      } catch (error2) {\n        if (error2 instanceof DOMException2 && error2.name === \"AbortError\") {\n          bail(new BlobRequestAbortedError());\n          return;\n        }\n        if (isNetworkError(error2)) {\n          throw error2;\n        }\n        if (error2 instanceof TypeError) {\n          bail(error2);\n          return;\n        }\n        throw error2;\n      }\n      if (res.ok) {\n        return res;\n      }\n      const { code, error } = await getBlobError(res);\n      if (code === \"unknown_error\" || code === \"service_unavailable\" || code === \"internal_server_error\") {\n        throw error;\n      }\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        if (error instanceof Error) {\n          debug(`retrying API request to ${pathname}`, error.message);\n        }\n        retryCount = retryCount + 1;\n      }\n    }\n  );\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: totalLoaded,\n      total: totalLoaded,\n      percentage: 100\n    });\n  }\n  return await apiResponse.json();\n}\nfunction getProxyThroughAlternativeApiHeaderFromEnv() {\n  const extraHeaders = {};\n  try {\n    if (\"VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    } else if (\"NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    }\n  } catch {\n  }\n  return extraHeaders;\n}\nfunction shouldUseXContentLength() {\n  try {\n    return process.env.VERCEL_BLOB_USE_X_CONTENT_LENGTH === \"1\";\n  } catch {\n    return false;\n  }\n}\n\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n  cacheControlMaxAge: \"x-cache-control-max-age\",\n  addRandomSuffix: \"x-add-random-suffix\",\n  contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n  const headers = {};\n  if (allowedOptions.includes(\"contentType\") && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n  if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n  }\n  return headers;\n}\nasync function createPutOptions({\n  pathname,\n  options,\n  extraChecks,\n  getToken\n}) {\n  if (!pathname) {\n    throw new BlobError(\"pathname is required\");\n  }\n  if (pathname.length > MAXIMUM_PATHNAME_LENGTH) {\n    throw new BlobError(\n      `pathname is too long, maximum length is ${MAXIMUM_PATHNAME_LENGTH}`\n    );\n  }\n  for (const invalidCharacter of disallowedPathnameCharacters) {\n    if (pathname.includes(invalidCharacter)) {\n      throw new BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`\n      );\n    }\n  }\n  if (!options) {\n    throw new BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new BlobError('access must be \"public\"');\n  }\n  if (extraChecks) {\n    extraChecks(options);\n  }\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n  return options;\n}\n\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, parts, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts\n    });\n  };\n}\nasync function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options\n}) {\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"content-type\": \"application/json\",\n          \"x-mpu-action\": \"complete\",\n          \"x-mpu-upload-id\": uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          \"x-mpu-key\": encodeURI(key)\n        },\n        body: JSON.stringify(parts),\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: complete\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId\n    };\n  };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n  debug(\"mpu: create\", \"pathname:\", pathname);\n  try {\n    const response = await requestApi(\n      `/mpu/${pathname}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"x-mpu-action\": \"create\"\n        },\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: create\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    }\n    throw error;\n  }\n}\n\n// src/multipart/upload.ts\n\n\nfunction createUploadPartMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, body, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options\n    });\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber\n    };\n  };\n}\nasync function uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  internalAbortController = new AbortController(),\n  part\n}) {\n  var _a3, _b2, _c;\n  const responsePromise = requestApi(\n    `/mpu/${pathname}`,\n    {\n      signal: internalAbortController.signal,\n      method: \"POST\",\n      headers: {\n        ...headers,\n        \"x-mpu-action\": \"upload\",\n        \"x-mpu-key\": encodeURI(key),\n        \"x-mpu-upload-id\": uploadId,\n        \"x-mpu-part-number\": part.partNumber.toString()\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob\n    },\n    options\n  );\n  function handleAbort() {\n    internalAbortController.abort();\n  }\n  if ((_a3 = options.abortSignal) == null ? void 0 : _a3.aborted) {\n    handleAbort();\n  } else {\n    (_b2 = options.abortSignal) == null ? void 0 : _b2.addEventListener(\"abort\", handleAbort);\n  }\n  const response = await responsePromise;\n  (_c = options.abortSignal) == null ? void 0 : _c.removeEventListener(\"abort\", handleAbort);\n  return response;\n}\nvar maxConcurrentUploads = typeof window !== \"undefined\" ? 6 : 8;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options,\n  totalToLoad\n}) {\n  debug(\"mpu: upload init\", \"key:\", key);\n  const internalAbortController = new AbortController();\n  return new Promise((resolve, reject) => {\n    const partsToUpload = [];\n    const completedParts = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n    let arrayBuffers = [];\n    let currentPartBytesRead = 0;\n    let onUploadProgress;\n    const totalLoadedPerPartNumber = {};\n    if (options.onUploadProgress) {\n      onUploadProgress = throttleit__WEBPACK_IMPORTED_MODULE_6__(() => {\n        var _a3;\n        const loaded = Object.values(totalLoadedPerPartNumber).reduce(\n          (acc, cur) => {\n            return acc + cur;\n          },\n          0\n        );\n        const total = totalToLoad || loaded;\n        const percentage = totalToLoad > 0 ? Number(((loaded / totalToLoad || loaded) * 100).toFixed(2)) : 0;\n        (_a3 = options.onUploadProgress) == null ? void 0 : _a3.call(options, { loaded, total, percentage });\n      }, 150);\n    }\n    read().catch(cancel);\n    async function read() {\n      debug(\n        \"mpu: upload read start\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_5__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_5__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_5__(bytesSent)\n      );\n      reading = true;\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          const { value, done } = await reader.read();\n          if (done) {\n            doneReading = true;\n            debug(\"mpu: upload read consumed the whole stream\");\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n          currentBytesInMemory += value.byteLength;\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength\n            );\n            const chunk = value.slice(valueOffset, endOffset);\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n      debug(\n        \"mpu: upload read end\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_5__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_5__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_5__(bytesSent)\n      );\n      reading = false;\n    }\n    async function sendPart(part) {\n      activeUploads++;\n      debug(\n        \"mpu: upload send part start\",\n        \"partNumber:\",\n        part.partNumber,\n        \"size:\",\n        part.blob.size,\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes__WEBPACK_IMPORTED_MODULE_5__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_5__(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes__WEBPACK_IMPORTED_MODULE_5__(bytesSent)\n      );\n      try {\n        const uploadProgressForPart = options.onUploadProgress ? (event) => {\n          totalLoadedPerPartNumber[part.partNumber] = event.loaded;\n          if (onUploadProgress) {\n            onUploadProgress();\n          }\n        } : void 0;\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options: {\n            ...options,\n            onUploadProgress: uploadProgressForPart\n          },\n          internalAbortController,\n          part\n        });\n        debug(\n          \"mpu: upload send part end\",\n          \"partNumber:\",\n          part.partNumber,\n          \"activeUploads\",\n          activeUploads,\n          \"currentBytesInMemory:\",\n          `${bytes__WEBPACK_IMPORTED_MODULE_5__(currentBytesInMemory)}/${bytes__WEBPACK_IMPORTED_MODULE_5__(maxBytesInMemory)}`,\n          \"bytesSent:\",\n          bytes__WEBPACK_IMPORTED_MODULE_5__(bytesSent)\n        );\n        if (rejected) {\n          return;\n        }\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag\n        });\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n    function sendParts() {\n      if (rejected) {\n        return;\n      }\n      debug(\n        \"send parts\",\n        \"activeUploads\",\n        activeUploads,\n        \"partsToUpload\",\n        partsToUpload.length\n      );\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n    function cancel(error) {\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error);\n      }\n    }\n  });\n}\n\n// src/put.ts\n\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n  debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n  const optionsWithoutOnUploadProgress = {\n    ...options,\n    onUploadProgress: void 0\n  };\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    optionsWithoutOnUploadProgress\n  );\n  const totalToLoad = computeBodyLength(body);\n  const stream = await toReadableStream(body);\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options,\n    totalToLoad\n  });\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options: optionsWithoutOnUploadProgress\n  });\n  return blob;\n}\n\n// src/put.ts\nfunction createPutMethod({\n  allowedOptions,\n  getToken,\n  extraChecks\n}) {\n  return async function put(pathname, body, optionsInput) {\n    if (!body) {\n      throw new BlobError(\"body is required\");\n    }\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (options.multipart === true) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n    const onUploadProgress = options.onUploadProgress ? throttleit__WEBPACK_IMPORTED_MODULE_6__(options.onUploadProgress, 100) : void 0;\n    const response = await requestApi(\n      `/${pathname}`,\n      {\n        method: \"PUT\",\n        body,\n        headers,\n        signal: options.abortSignal\n      },\n      {\n        ...options,\n        onUploadProgress\n      }\n    );\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition\n    };\n  };\n}\n\n// src/multipart/create-uploader.ts\nfunction createCreateMultipartUploaderMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n      async uploadPart(partNumber, body) {\n        if (isPlainObject(body)) {\n          throw new BlobError(\n            \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n          );\n        }\n        const result = await uploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options\n        });\n        return {\n          etag: result.etag,\n          partNumber\n        };\n      },\n      async complete(parts) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options\n        });\n      }\n    };\n  };\n}\n\n// src/create-folder.ts\nasync function createFolder(pathname, options = {}) {\n  const path = pathname.endsWith(\"/\") ? pathname : `${pathname}/`;\n  const headers = {};\n  headers[putOptionHeaderMap.addRandomSuffix] = \"0\";\n  const response = await requestApi(\n    `/${path}`,\n    {\n      method: \"PUT\",\n      headers,\n      signal: options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    pathname: response.pathname\n  };\n}\n\n\n//# sourceMappingURL=chunk-KN6WT5GP.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL2Jsb2IvZGlzdC9jaHVuay1LTjZXVDVHUC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDZ0Q7O0FBRWhEO0FBQ2tDO0FBQ0Q7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBUTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhEQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLDZDQUE2QyxFQUFFLFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEyQkU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxZYXNpclxcT25lRHJpdmVcXERlc2t0b3BcXDEtOCBhbGV4aXNcXGFsZXhpcy1ib2x0XFxub2RlX21vZHVsZXNcXEB2ZXJjZWxcXGJsb2JcXGRpc3RcXGNodW5rLUtONldUNUdQLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9oZWxwZXJzLnRzXG5pbXBvcnQgeyBpc05vZGVQcm9jZXNzIH0gZnJvbSBcImlzLW5vZGUtcHJvY2Vzc1wiO1xuXG4vLyBzcmMvbXVsdGlwYXJ0L2hlbHBlcnMudHNcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSBcInN0cmVhbVwiO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gXCJpcy1idWZmZXJcIjtcbnZhciBzdXBwb3J0c05ld0Jsb2JGcm9tQXJyYXlCdWZmZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGhlbGxvQXNBcnJheUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KFsxMDQsIDEwMSwgMTA4LCAxMDgsIDExMV0pO1xuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbaGVsbG9Bc0FycmF5QnVmZmVyXSk7XG4gICAgYmxvYi50ZXh0KCkudGhlbigodGV4dCkgPT4ge1xuICAgICAgcmVzb2x2ZSh0ZXh0ID09PSBcImhlbGxvXCIpO1xuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH0pO1xuICB9IGNhdGNoIHtcbiAgICByZXNvbHZlKGZhbHNlKTtcbiAgfVxufSk7XG5hc3luYyBmdW5jdGlvbiB0b1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gdmFsdWUuc3RyZWFtKCk7XG4gIH1cbiAgaWYgKGlzTm9kZUpzUmVhZGFibGVTdHJlYW0odmFsdWUpKSB7XG4gICAgcmV0dXJuIFJlYWRhYmxlLnRvV2ViKHZhbHVlKTtcbiAgfVxuICBsZXQgc3RyZWFtVmFsdWU7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgc3RyZWFtVmFsdWUgPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNOb2RlSnNCdWZmZXIodmFsdWUpKSB7XG4gICAgc3RyZWFtVmFsdWUgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW1WYWx1ZSA9IHN0cmluZ1RvVWludDhBcnJheSh2YWx1ZSk7XG4gIH1cbiAgaWYgKGF3YWl0IHN1cHBvcnRzTmV3QmxvYkZyb21BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgQmxvYihbc3RyZWFtVmFsdWVdKS5zdHJlYW0oKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoc3RyZWFtVmFsdWUpO1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc05vZGVKc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnBpcGUgPT09IFwiZnVuY3Rpb25cIiAmJiB2YWx1ZS5yZWFkYWJsZSAmJiB0eXBlb2YgdmFsdWUuX3JlYWQgPT09IFwiZnVuY3Rpb25cIiAmJiAvLyBAdHMtZXhwZWN0LWVycm9yIF9yZWFkYWJsZVN0YXRlIGRvZXMgZXhpc3RzIG9uIFJlYWRhYmxlXG4gIHR5cGVvZiB2YWx1ZS5fcmVhZGFibGVTdGF0ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVWludDhBcnJheShzKSB7XG4gIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICByZXR1cm4gZW5jLmVuY29kZShzKTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUpzQnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiBpc0J1ZmZlcih2YWx1ZSk7XG59XG5cbi8vIHNyYy9oZWxwZXJzLnRzXG5mdW5jdGlvbiBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50b2tlbikge1xuICAgIHJldHVybiBvcHRpb25zLnRva2VuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5CTE9CX1JFQURfV1JJVEVfVE9LRU4pIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQkxPQl9SRUFEX1dSSVRFX1RPS0VOO1xuICB9XG4gIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgXCJObyB0b2tlbiBmb3VuZC4gRWl0aGVyIGNvbmZpZ3VyZSB0aGUgYEJMT0JfUkVBRF9XUklURV9UT0tFTmAgZW52aXJvbm1lbnQgdmFyaWFibGUsIG9yIHBhc3MgYSBgdG9rZW5gIG9wdGlvbiB0byB5b3VyIGNhbGxzLlwiXG4gICk7XG59XG52YXIgQmxvYkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihgVmVyY2VsIEJsb2I6ICR7bWVzc2FnZX1gKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERvd25sb2FkVXJsKGJsb2JVcmwpIHtcbiAgY29uc3QgdXJsID0gbmV3IFVSTChibG9iVXJsKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJkb3dubG9hZFwiLCBcIjFcIik7XG4gIHJldHVybiB1cmwudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSk7XG59XG52YXIgZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycyA9IFtcIiNcIiwgXCI/XCIsIFwiLy9cIl07XG52YXIgc3VwcG9ydHNSZXF1ZXN0U3RyZWFtcyA9ICgoKSA9PiB7XG4gIGlmIChpc05vZGVQcm9jZXNzKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcbiAgY29uc3QgaGFzQ29udGVudFR5cGUgPSBuZXcgUmVxdWVzdChnZXRBcGlVcmwoKSwge1xuICAgIGJvZHk6IG5ldyBSZWFkYWJsZVN0cmVhbSgpLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBUeXBlU2NyaXB0IGRvZXNuJ3QgeWV0IGhhdmUgZHVwbGV4IGJ1dCBpdCdzIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNzI5XG4gICAgZ2V0IGR1cGxleCgpIHtcbiAgICAgIGR1cGxleEFjY2Vzc2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcImhhbGZcIjtcbiAgICB9XG4gIH0pLmhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpO1xuICByZXR1cm4gZHVwbGV4QWNjZXNzZWQgJiYgIWhhc0NvbnRlbnRUeXBlO1xufSkoKTtcbmZ1bmN0aW9uIGdldEFwaVVybChwYXRobmFtZSA9IFwiXCIpIHtcbiAgbGV0IGJhc2VVcmwgPSBudWxsO1xuICB0cnkge1xuICAgIGJhc2VVcmwgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9BUElfVVJMIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX0FQSV9VUkw7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBgJHtiYXNlVXJsIHx8IFwiaHR0cHM6Ly9ibG9iLnZlcmNlbC1zdG9yYWdlLmNvbVwifSR7cGF0aG5hbWV9YDtcbn1cbnZhciBURVhUX0VOQ09ERVIgPSB0eXBlb2YgVGV4dEVuY29kZXIgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBUZXh0RW5jb2RlcigpIDogbnVsbDtcbmZ1bmN0aW9uIGNvbXB1dGVCb2R5TGVuZ3RoKGJvZHkpIHtcbiAgaWYgKCFib2R5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKFRFWFRfRU5DT0RFUikge1xuICAgICAgcmV0dXJuIFRFWFRfRU5DT0RFUi5lbmNvZGUoYm9keSkuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtib2R5XSkuc2l6ZTtcbiAgfVxuICBpZiAoXCJieXRlTGVuZ3RoXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5ieXRlTGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aDtcbiAgfVxuICBpZiAoXCJzaXplXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5zaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGJvZHkuc2l6ZTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBjcmVhdGVDaHVua1RyYW5zZm9ybVN0cmVhbSA9IChjaHVua1NpemUsIG9uUHJvZ3Jlc3MpID0+IHtcbiAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5sZW5ndGggKyBjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICBuZXdCdWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGNodW5rKSwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGggPj0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q2h1bmsgPSBidWZmZXIuc2xpY2UoMCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3Q2h1bmspO1xuICAgICAgICAgIG9uUHJvZ3Jlc3MgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUHJvZ3Jlc3MobmV3Q2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGNodW5rU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYnVmZmVyKTtcbiAgICAgICAgICBvblByb2dyZXNzID09IG51bGwgPyB2b2lkIDAgOiBvblByb2dyZXNzKGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5mdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24gLS0gTm90IHByZXNlbnQgaW4gTm9kZS5qcyAxNlxuICAgIGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gJiYgLy8gVE9ETzogQ2FuIGJlIHJlbW92ZWQgb25jZSBOb2RlLmpzIDE2IGlzIG5vIG1vcmUgcmVxdWlyZWQgaW50ZXJuYWxseVxuICAgIHZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1cbiAgKTtcbn1cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc05vZGVKc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL2FwaS50c1xuaW1wb3J0IHJldHJ5IGZyb20gXCJhc3luYy1yZXRyeVwiO1xuXG4vLyBzcmMvaXMtbmV0d29yay1lcnJvci50c1xudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Vycm9yID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEVycm9yXVwiO1xudmFyIGVycm9yTWVzc2FnZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwibmV0d29yayBlcnJvclwiLFxuICAvLyBDaHJvbWVcbiAgXCJGYWlsZWQgdG8gZmV0Y2hcIixcbiAgLy8gQ2hyb21lXG4gIFwiTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS5cIixcbiAgLy8gRmlyZWZveFxuICBcIlRoZSBJbnRlcm5ldCBjb25uZWN0aW9uIGFwcGVhcnMgdG8gYmUgb2ZmbGluZS5cIixcbiAgLy8gU2FmYXJpIDE2XG4gIFwiTG9hZCBmYWlsZWRcIixcbiAgLy8gU2FmYXJpIDE3K1xuICBcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIixcbiAgLy8gYGNyb3NzLWZldGNoYFxuICBcImZldGNoIGZhaWxlZFwiLFxuICAvLyBVbmRpY2kgKE5vZGUuanMpXG4gIFwidGVybWluYXRlZFwiXG4gIC8vIFVuZGljaSAoTm9kZS5qcylcbl0pO1xuZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IoZXJyb3IpIHtcbiAgY29uc3QgaXNWYWxpZCA9IGVycm9yICYmIGlzRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09IFwiVHlwZUVycm9yXCIgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCI7XG4gIGlmICghaXNWYWxpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gXCJMb2FkIGZhaWxlZFwiKSB7XG4gICAgcmV0dXJuIGVycm9yLnN0YWNrID09PSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGVycm9yTWVzc2FnZXMuaGFzKGVycm9yLm1lc3NhZ2UpO1xufVxuXG4vLyBzcmMvZGVidWcudHNcbnZhciBkZWJ1Z0lzQWN0aXZlID0gZmFsc2U7XG52YXIgX2EsIF9iO1xudHJ5IHtcbiAgaWYgKCgoX2EgPSBwcm9jZXNzLmVudi5ERUJVRykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiYmxvYlwiKSkgfHwgKChfYiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0RFQlVHKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJibG9iXCIpKSkge1xuICAgIGRlYnVnSXNBY3RpdmUgPSB0cnVlO1xuICB9XG59IGNhdGNoIChlcnJvcikge1xufVxuZnVuY3Rpb24gZGVidWcobWVzc2FnZSwgLi4uYXJncykge1xuICBpZiAoZGVidWdJc0FjdGl2ZSkge1xuICAgIGNvbnNvbGUuZGVidWcoYHZlcmNlbC1ibG9iOiAke21lc3NhZ2V9YCwgLi4uYXJncyk7XG4gIH1cbn1cblxuLy8gc3JjL2ZldGNoLnRzXG5pbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJ1bmRpY2lcIjtcbnZhciBoYXNGZXRjaCA9IHR5cGVvZiBmZXRjaCA9PT0gXCJmdW5jdGlvblwiO1xudmFyIGhhc0ZldGNoV2l0aFVwbG9hZFByb2dyZXNzID0gaGFzRmV0Y2ggJiYgc3VwcG9ydHNSZXF1ZXN0U3RyZWFtcztcbnZhciBDSFVOS19TSVpFID0gNjQgKiAxMDI0O1xudmFyIGJsb2JGZXRjaCA9IGFzeW5jICh7XG4gIGlucHV0LFxuICBpbml0LFxuICBvblVwbG9hZFByb2dyZXNzXG59KSA9PiB7XG4gIGRlYnVnKFwidXNpbmcgZmV0Y2hcIik7XG4gIGxldCBib2R5O1xuICBpZiAoaW5pdC5ib2R5KSB7XG4gICAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRvUmVhZGFibGVTdHJlYW0oaW5pdC5ib2R5KTtcbiAgICAgIGxldCBsb2FkZWQgPSAwO1xuICAgICAgY29uc3QgY2h1bmtUcmFuc2Zvcm1TdHJlYW0gPSBjcmVhdGVDaHVua1RyYW5zZm9ybVN0cmVhbShcbiAgICAgICAgQ0hVTktfU0laRSxcbiAgICAgICAgKG5ld0xvYWRlZCkgPT4ge1xuICAgICAgICAgIGxvYWRlZCArPSBuZXdMb2FkZWQ7XG4gICAgICAgICAgb25VcGxvYWRQcm9ncmVzcyhsb2FkZWQpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgYm9keSA9IHN0cmVhbS5waXBlVGhyb3VnaChjaHVua1RyYW5zZm9ybVN0cmVhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkgPSBpbml0LmJvZHk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGR1cGxleCA9IHN1cHBvcnRzUmVxdWVzdFN0cmVhbXMgJiYgYm9keSAmJiBpc1N0cmVhbShib2R5KSA/IFwiaGFsZlwiIDogdm9pZCAwO1xuICByZXR1cm4gZmV0Y2goXG4gICAgaW5wdXQsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBCbG9iIGFuZCBOb2RlanMgQmxvYiBhcmUgdHJpZ2dlcmluZyB0eXBlIGVycm9ycywgZmluZSB3aXRoIGl0XG4gICAge1xuICAgICAgLi4uaW5pdCxcbiAgICAgIC4uLmluaXQuYm9keSA/IHsgYm9keSB9IDoge30sXG4gICAgICBkdXBsZXhcbiAgICB9XG4gICk7XG59O1xuXG4vLyBzcmMveGhyLnRzXG52YXIgaGFzWGhyID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIGJsb2JYaHIgPSBhc3luYyAoe1xuICBpbnB1dCxcbiAgaW5pdCxcbiAgb25VcGxvYWRQcm9ncmVzc1xufSkgPT4ge1xuICBkZWJ1ZyhcInVzaW5nIHhoclwiKTtcbiAgbGV0IGJvZHkgPSBudWxsO1xuICBpZiAoaW5pdC5ib2R5KSB7XG4gICAgaWYgKGlzUmVhZGFibGVTdHJlYW0oaW5pdC5ib2R5KSkge1xuICAgICAgYm9keSA9IGF3YWl0IG5ldyBSZXNwb25zZShpbml0LmJvZHkpLmJsb2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IGluaXQuYm9keTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3Blbihpbml0Lm1ldGhvZCB8fCBcIkdFVFwiLCBpbnB1dC50b1N0cmluZygpLCB0cnVlKTtcbiAgICBpZiAob25VcGxvYWRQcm9ncmVzcykge1xuICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgb25VcGxvYWRQcm9ncmVzcyhldmVudC5sb2FkZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHZhciBfYTM7XG4gICAgICBpZiAoKF9hMyA9IGluaXQuc2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmFib3J0ZWQpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBET01FeGNlcHRpb24oXCJUaGUgdXNlciBhYm9ydGVkIHRoZSByZXF1ZXN0LlwiLCBcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgIGNvbnN0IHJhd0hlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkudHJpbSgpLnNwbGl0KC9bXFxyXFxuXSsvKTtcbiAgICAgIHJhd0hlYWRlcnMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoXCI6IFwiKTtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5qb2luKFwiOiBcIik7XG4gICAgICAgIGlmIChrZXkpIGhlYWRlcnMuc2V0KGtleS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHhoci5yZXNwb25zZSwge1xuICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9KTtcbiAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IFR5cGVFcnJvcihcIk5ldHdvcmsgcmVxdWVzdCBmYWlsZWRcIikpO1xuICAgIH07XG4gICAgeGhyLm9udGltZW91dCA9ICgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKFwiTmV0d29yayByZXF1ZXN0IHRpbWVkIG91dFwiKSk7XG4gICAgfTtcbiAgICB4aHIub25hYm9ydCA9ICgpID0+IHtcbiAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKFwiVGhlIHVzZXIgYWJvcnRlZCBhIHJlcXVlc3QuXCIsIFwiQWJvcnRFcnJvclwiKSk7XG4gICAgfTtcbiAgICBpZiAoaW5pdC5oZWFkZXJzKSB7XG4gICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKTtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5pdC5zaWduYWwpIHtcbiAgICAgIGluaXQuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5pdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB4aHIuc2VuZChib2R5KTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvcmVxdWVzdC50c1xudmFyIGJsb2JSZXF1ZXN0ID0gYXN5bmMgKHtcbiAgaW5wdXQsXG4gIGluaXQsXG4gIG9uVXBsb2FkUHJvZ3Jlc3Ncbn0pID0+IHtcbiAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICBpZiAoaGFzRmV0Y2hXaXRoVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybiBibG9iRmV0Y2goeyBpbnB1dCwgaW5pdCwgb25VcGxvYWRQcm9ncmVzcyB9KTtcbiAgICB9XG4gICAgaWYgKGhhc1hocikge1xuICAgICAgcmV0dXJuIGJsb2JYaHIoeyBpbnB1dCwgaW5pdCwgb25VcGxvYWRQcm9ncmVzcyB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc0ZldGNoKSB7XG4gICAgcmV0dXJuIGJsb2JGZXRjaCh7IGlucHV0LCBpbml0IH0pO1xuICB9XG4gIGlmIChoYXNYaHIpIHtcbiAgICByZXR1cm4gYmxvYlhocih7IGlucHV0LCBpbml0IH0pO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIk5vIHJlcXVlc3QgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlXCIpO1xufTtcblxuLy8gc3JjL2RvbS1leGNlcHRpb24udHNcbnZhciBfYTI7XG52YXIgRE9NRXhjZXB0aW9uMiA9IChfYTIgPSBnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbikgIT0gbnVsbCA/IF9hMiA6ICgoKSA9PiB7XG4gIHRyeSB7XG4gICAgYXRvYihcIn5cIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXJyKS5jb25zdHJ1Y3RvcjtcbiAgfVxufSkoKTtcblxuLy8gc3JjL2FwaS50c1xudmFyIE1BWElNVU1fUEFUSE5BTUVfTEVOR1RIID0gOTUwO1xudmFyIEJsb2JBY2Nlc3NFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJBY2Nlc3MgZGVuaWVkLCBwbGVhc2UgcHJvdmlkZSBhIHZhbGlkIHRva2VuIGZvciB0aGlzIHJlc291cmNlLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iQ29udGVudFR5cGVOb3RBbGxvd2VkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihgQ29udGVudCB0eXBlIG1pc21hdGNoLCAke21lc3NhZ2V9LmApO1xuICB9XG59O1xudmFyIEJsb2JQYXRobmFtZU1pc21hdGNoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihcbiAgICAgIGBQYXRobmFtZSBtaXNtYXRjaCwgJHttZXNzYWdlfS4gQ2hlY2sgdGhlIHBhdGhuYW1lIHVzZWQgaW4gdXBsb2FkKCkgb3IgcHV0KCkgbWF0Y2hlcyB0aGUgb25lIGZyb20gdGhlIGNsaWVudCB0b2tlbi5gXG4gICAgKTtcbiAgfVxufTtcbnZhciBCbG9iQ2xpZW50VG9rZW5FeHBpcmVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiQ2xpZW50IHRva2VuIGhhcyBleHBpcmVkLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iRmlsZVRvb0xhcmdlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihgRmlsZSBpcyB0b28gbGFyZ2UsICR7bWVzc2FnZX0uYCk7XG4gIH1cbn07XG52YXIgQmxvYlN0b3JlTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGlzIHN0b3JlIGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgfVxufTtcbnZhciBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGlzIHN0b3JlIGhhcyBiZWVuIHN1c3BlbmRlZC5cIik7XG4gIH1cbn07XG52YXIgQmxvYlVua25vd25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJVbmtub3duIGVycm9yLCBwbGVhc2UgdmlzaXQgaHR0cHM6Ly92ZXJjZWwuY29tL2hlbHAuXCIpO1xuICB9XG59O1xudmFyIEJsb2JOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlRoZSByZXF1ZXN0ZWQgYmxvYiBkb2VzIG5vdCBleGlzdFwiKTtcbiAgfVxufTtcbnZhciBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGUgYmxvYiBzZXJ2aWNlIGlzIGN1cnJlbnRseSBub3QgYXZhaWxhYmxlLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iU2VydmljZVJhdGVMaW1pdGVkID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzZWNvbmRzKSB7XG4gICAgc3VwZXIoXG4gICAgICBgVG9vIG1hbnkgcmVxdWVzdHMgcGxlYXNlIGxvd2VyIHRoZSBudW1iZXIgb2YgY29uY3VycmVudCByZXF1ZXN0cyAke3NlY29uZHMgPyBgIC0gdHJ5IGFnYWluIGluICR7c2Vjb25kc30gc2Vjb25kc2AgOiBcIlwifS5gXG4gICAgKTtcbiAgICB0aGlzLnJldHJ5QWZ0ZXIgPSBzZWNvbmRzICE9IG51bGwgPyBzZWNvbmRzIDogMDtcbiAgfVxufTtcbnZhciBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGUgcmVxdWVzdCB3YXMgYWJvcnRlZC5cIik7XG4gIH1cbn07XG52YXIgQkxPQl9BUElfVkVSU0lPTiA9IDg7XG5mdW5jdGlvbiBnZXRBcGlWZXJzaW9uKCkge1xuICBsZXQgdmVyc2lvbk92ZXJyaWRlID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uT3ZlcnJpZGUgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9BUElfVkVSU0lPTl9PVkVSUklERSB8fCBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9BUElfVkVSU0lPTl9PVkVSUklERTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGAke3ZlcnNpb25PdmVycmlkZSAhPSBudWxsID8gdmVyc2lvbk92ZXJyaWRlIDogQkxPQl9BUElfVkVSU0lPTn1gO1xufVxuZnVuY3Rpb24gZ2V0UmV0cmllcygpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXRyaWVzID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfUkVUUklFUyB8fCBcIjEwXCI7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJldHJpZXMsIDEwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIDEwO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9iU2VydmljZVJhdGVMaW1pdGVkKHJlc3BvbnNlKSB7XG4gIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcInJldHJ5LWFmdGVyXCIpO1xuICByZXR1cm4gbmV3IEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQoXG4gICAgcmV0cnlBZnRlciA/IHBhcnNlSW50KHJldHJ5QWZ0ZXIsIDEwKSA6IHZvaWQgMFxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvYkVycm9yKHJlc3BvbnNlKSB7XG4gIHZhciBfYTMsIF9iMiwgX2M7XG4gIGxldCBjb2RlO1xuICBsZXQgbWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvZGUgPSAoX2IyID0gKF9hMyA9IGRhdGEuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY29kZSkgIT0gbnVsbCA/IF9iMiA6IFwidW5rbm93bl9lcnJvclwiO1xuICAgIG1lc3NhZ2UgPSAoX2MgPSBkYXRhLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2MubWVzc2FnZTtcbiAgfSBjYXRjaCB7XG4gICAgY29kZSA9IFwidW5rbm93bl9lcnJvclwiO1xuICB9XG4gIGlmICgobWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZS5pbmNsdWRlcyhcImNvbnRlbnRUeXBlXCIpKSAmJiBtZXNzYWdlLmluY2x1ZGVzKFwiaXMgbm90IGFsbG93ZWRcIikpIHtcbiAgICBjb2RlID0gXCJjb250ZW50X3R5cGVfbm90X2FsbG93ZWRcIjtcbiAgfVxuICBpZiAoKG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UuaW5jbHVkZXMoJ1wicGF0aG5hbWVcIicpKSAmJiBtZXNzYWdlLmluY2x1ZGVzKFwiZG9lcyBub3QgbWF0Y2ggdGhlIHRva2VuIHBheWxvYWRcIikpIHtcbiAgICBjb2RlID0gXCJjbGllbnRfdG9rZW5fcGF0aG5hbWVfbWlzbWF0Y2hcIjtcbiAgfVxuICBpZiAobWVzc2FnZSA9PT0gXCJUb2tlbiBleHBpcmVkXCIpIHtcbiAgICBjb2RlID0gXCJjbGllbnRfdG9rZW5fZXhwaXJlZFwiO1xuICB9XG4gIGlmIChtZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlLmluY2x1ZGVzKFwidGhlIGZpbGUgbGVuZ3RoIGNhbm5vdCBiZSBncmVhdGVyIHRoYW5cIikpIHtcbiAgICBjb2RlID0gXCJmaWxlX3Rvb19sYXJnZVwiO1xuICB9XG4gIGxldCBlcnJvcjtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSBcInN0b3JlX3N1c3BlbmRlZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmb3JiaWRkZW5cIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JBY2Nlc3NFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvbnRlbnRfdHlwZV9ub3RfYWxsb3dlZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yKG1lc3NhZ2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNsaWVudF90b2tlbl9wYXRobmFtZV9taXNtYXRjaFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlBhdGhuYW1lTWlzbWF0Y2hFcnJvcihtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjbGllbnRfdG9rZW5fZXhwaXJlZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkNsaWVudFRva2VuRXhwaXJlZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZmlsZV90b29fbGFyZ2VcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JGaWxlVG9vTGFyZ2VFcnJvcihtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub3RfZm91bmRcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JOb3RGb3VuZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3RvcmVfbm90X2ZvdW5kXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU3RvcmVOb3RGb3VuZEVycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYmFkX3JlcXVlc3RcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JFcnJvcihtZXNzYWdlICE9IG51bGwgPyBtZXNzYWdlIDogXCJCYWQgcmVxdWVzdFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzZXJ2aWNlX3VuYXZhaWxhYmxlXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJhdGVfbGltaXRlZFwiOlxuICAgICAgZXJyb3IgPSBjcmVhdGVCbG9iU2VydmljZVJhdGVMaW1pdGVkKHJlc3BvbnNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ1bmtub3duX2Vycm9yXCI6XG4gICAgY2FzZSBcIm5vdF9hbGxvd2VkXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JVbmtub3duRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7IGNvZGUsIGVycm9yIH07XG59XG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0QXBpKHBhdGhuYW1lLCBpbml0LCBjb21tYW5kT3B0aW9ucykge1xuICBjb25zdCBhcGlWZXJzaW9uID0gZ2V0QXBpVmVyc2lvbigpO1xuICBjb25zdCB0b2tlbiA9IGdldFRva2VuRnJvbU9wdGlvbnNPckVudihjb21tYW5kT3B0aW9ucyk7XG4gIGNvbnN0IGV4dHJhSGVhZGVycyA9IGdldFByb3h5VGhyb3VnaEFsdGVybmF0aXZlQXBpSGVhZGVyRnJvbUVudigpO1xuICBjb25zdCBbLCAsICwgc3RvcmVJZCA9IFwiXCJdID0gdG9rZW4uc3BsaXQoXCJfXCIpO1xuICBjb25zdCByZXF1ZXN0SWQgPSBgJHtzdG9yZUlkfToke0RhdGUubm93KCl9OiR7TWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc2xpY2UoMil9YDtcbiAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICBsZXQgYm9keUxlbmd0aCA9IDA7XG4gIGxldCB0b3RhbExvYWRlZCA9IDA7XG4gIGNvbnN0IHNlbmRCb2R5TGVuZ3RoID0gKGNvbW1hbmRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSB8fCBzaG91bGRVc2VYQ29udGVudExlbmd0aCgpO1xuICBpZiAoaW5pdC5ib2R5ICYmIC8vIDEuIEZvciB1cGxvYWQgcHJvZ3Jlc3Mgd2UgYWx3YXlzIG5lZWQgdG8ga25vdyB0aGUgdG90YWwgc2l6ZSBvZiB0aGUgYm9keVxuICAvLyAyLiBJbiBkZXZlbG9wbWVudCB3ZSBuZWVkIHRoZSBoZWFkZXIgZm9yIHB1dCgpIHRvIHdvcmsgY29ycmVjdGx5IHdoZW4gcGFzc2luZyBhIHN0cmVhbVxuICBzZW5kQm9keUxlbmd0aCkge1xuICAgIGJvZHlMZW5ndGggPSBjb21wdXRlQm9keUxlbmd0aChpbml0LmJvZHkpO1xuICB9XG4gIGlmIChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgIGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3Moe1xuICAgICAgbG9hZGVkOiAwLFxuICAgICAgdG90YWw6IGJvZHlMZW5ndGgsXG4gICAgICBwZXJjZW50YWdlOiAwXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYXBpUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICBhc3luYyAoYmFpbCkgPT4ge1xuICAgICAgbGV0IHJlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGJsb2JSZXF1ZXN0KHtcbiAgICAgICAgICBpbnB1dDogZ2V0QXBpVXJsKHBhdGhuYW1lKSxcbiAgICAgICAgICBpbml0OiB7XG4gICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIngtYXBpLWJsb2ItcmVxdWVzdC1pZFwiOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIFwieC1hcGktYmxvYi1yZXF1ZXN0LWF0dGVtcHRcIjogU3RyaW5nKHJldHJ5Q291bnQpLFxuICAgICAgICAgICAgICBcIngtYXBpLXZlcnNpb25cIjogYXBpVmVyc2lvbixcbiAgICAgICAgICAgICAgLi4uc2VuZEJvZHlMZW5ndGggPyB7IFwieC1jb250ZW50LWxlbmd0aFwiOiBTdHJpbmcoYm9keUxlbmd0aCkgfSA6IHt9LFxuICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgICAgICAgLi4uZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAuLi5pbml0LmhlYWRlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykgPyAobG9hZGVkKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EzO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSBib2R5TGVuZ3RoICE9PSAwID8gYm9keUxlbmd0aCA6IGxvYWRlZDtcbiAgICAgICAgICAgIHRvdGFsTG9hZGVkID0gbG9hZGVkO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGJvZHlMZW5ndGggPiAwID8gTnVtYmVyKChsb2FkZWQgLyB0b3RhbCAqIDEwMCkudG9GaXhlZCgyKSkgOiAwO1xuICAgICAgICAgICAgaWYgKHBlcmNlbnRhZ2UgPT09IDEwMCAmJiBib2R5TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2EzID0gY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKGNvbW1hbmRPcHRpb25zLCB7XG4gICAgICAgICAgICAgIGxvYWRlZCxcbiAgICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGEgc3RyZWFtIHRvIHB1dCgpLCB3ZSBoYXZlIG5vIHdheSB0byBrbm93IHRoZSB0b3RhbCBzaXplIG9mIHRoZSBib2R5LlxuICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGRlZmluaW5nIHRvdGFsIGFzIHRvdGFsPzogbnVtYmVyIHdlIGRlY2lkZWQgdG8gc2V0IHRoZSB0b3RhbCB0byB0aGUgY3VycmVudGx5XG4gICAgICAgICAgICAgIC8vIGxvYWRlZCBudW1iZXIuIFRoaXMgaXMgbm90IGluYWNjdXJhdGUgYW5kIHdheSBtb3JlIHByYWN0aWNhbCBmb3IgRFguXG4gICAgICAgICAgICAgIC8vIFBhc3NpbmcgZG93biBhIHN0cmVhbSB0byBwdXQoKSBpcyB2ZXJ5IHJhcmVcbiAgICAgICAgICAgICAgdG90YWwsXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbjIgJiYgZXJyb3IyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgYmFpbChuZXcgQmxvYlJlcXVlc3RBYm9ydGVkRXJyb3IoKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldHdvcmtFcnJvcihlcnJvcjIpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcjIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICBiYWlsKGVycm9yMik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yMjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29kZSwgZXJyb3IgfSA9IGF3YWl0IGdldEJsb2JFcnJvcihyZXMpO1xuICAgICAgaWYgKGNvZGUgPT09IFwidW5rbm93bl9lcnJvclwiIHx8IGNvZGUgPT09IFwic2VydmljZV91bmF2YWlsYWJsZVwiIHx8IGNvZGUgPT09IFwiaW50ZXJuYWxfc2VydmVyX2Vycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBiYWlsKGVycm9yKTtcbiAgICB9LFxuICAgIHtcbiAgICAgIHJldHJpZXM6IGdldFJldHJpZXMoKSxcbiAgICAgIG9uUmV0cnk6IChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGRlYnVnKGByZXRyeWluZyBBUEkgcmVxdWVzdCB0byAke3BhdGhuYW1lfWAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHJ5Q291bnQgPSByZXRyeUNvdW50ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIGlmICghYXBpUmVzcG9uc2UpIHtcbiAgICB0aHJvdyBuZXcgQmxvYlVua25vd25FcnJvcigpO1xuICB9XG4gIGlmIChjb21tYW5kT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgIGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3Moe1xuICAgICAgbG9hZGVkOiB0b3RhbExvYWRlZCxcbiAgICAgIHRvdGFsOiB0b3RhbExvYWRlZCxcbiAgICAgIHBlcmNlbnRhZ2U6IDEwMFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhd2FpdCBhcGlSZXNwb25zZS5qc29uKCk7XG59XG5mdW5jdGlvbiBnZXRQcm94eVRocm91Z2hBbHRlcm5hdGl2ZUFwaUhlYWRlckZyb21FbnYoKSB7XG4gIGNvbnN0IGV4dHJhSGVhZGVycyA9IHt9O1xuICB0cnkge1xuICAgIGlmIChcIlZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJXCIgaW4gcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUEkgIT09IHZvaWQgMCkge1xuICAgICAgZXh0cmFIZWFkZXJzW1wieC1wcm94eS10aHJvdWdoLWFsdGVybmF0aXZlLWFwaVwiXSA9IHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJO1xuICAgIH0gZWxzZSBpZiAoXCJORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSVwiIGluIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJICE9PSB2b2lkIDApIHtcbiAgICAgIGV4dHJhSGVhZGVyc1tcIngtcHJveHktdGhyb3VnaC1hbHRlcm5hdGl2ZS1hcGlcIl0gPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBleHRyYUhlYWRlcnM7XG59XG5mdW5jdGlvbiBzaG91bGRVc2VYQ29udGVudExlbmd0aCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfVVNFX1hfQ09OVEVOVF9MRU5HVEggPT09IFwiMVwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gc3JjL3B1dC1oZWxwZXJzLnRzXG52YXIgcHV0T3B0aW9uSGVhZGVyTWFwID0ge1xuICBjYWNoZUNvbnRyb2xNYXhBZ2U6IFwieC1jYWNoZS1jb250cm9sLW1heC1hZ2VcIixcbiAgYWRkUmFuZG9tU3VmZml4OiBcIngtYWRkLXJhbmRvbS1zdWZmaXhcIixcbiAgY29udGVudFR5cGU6IFwieC1jb250ZW50LXR5cGVcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJjb250ZW50VHlwZVwiKSAmJiBvcHRpb25zLmNvbnRlbnRUeXBlKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuY29udGVudFR5cGVdID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJhZGRSYW5kb21TdWZmaXhcIikgJiYgb3B0aW9ucy5hZGRSYW5kb21TdWZmaXggIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmFkZFJhbmRvbVN1ZmZpeF0gPSBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKGFsbG93ZWRPcHRpb25zLmluY2x1ZGVzKFwiY2FjaGVDb250cm9sTWF4QWdlXCIpICYmIG9wdGlvbnMuY2FjaGVDb250cm9sTWF4QWdlICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5jYWNoZUNvbnRyb2xNYXhBZ2VdID0gb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVB1dE9wdGlvbnMoe1xuICBwYXRobmFtZSxcbiAgb3B0aW9ucyxcbiAgZXh0cmFDaGVja3MsXG4gIGdldFRva2VuXG59KSB7XG4gIGlmICghcGF0aG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwicGF0aG5hbWUgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgaWYgKHBhdGhuYW1lLmxlbmd0aCA+IE1BWElNVU1fUEFUSE5BTUVfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgIGBwYXRobmFtZSBpcyB0b28gbG9uZywgbWF4aW11bSBsZW5ndGggaXMgJHtNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSH1gXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IGludmFsaWRDaGFyYWN0ZXIgb2YgZGlzYWxsb3dlZFBhdGhuYW1lQ2hhcmFjdGVycykge1xuICAgIGlmIChwYXRobmFtZS5pbmNsdWRlcyhpbnZhbGlkQ2hhcmFjdGVyKSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgYHBhdGhuYW1lIGNhbm5vdCBjb250YWluIFwiJHtpbnZhbGlkQ2hhcmFjdGVyfVwiLCBwbGVhc2UgZW5jb2RlIGl0IGlmIG5lZWRlZGBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJtaXNzaW5nIG9wdGlvbnMsIHNlZSB1c2FnZVwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hY2Nlc3MgIT09IFwicHVibGljXCIpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKCdhY2Nlc3MgbXVzdCBiZSBcInB1YmxpY1wiJyk7XG4gIH1cbiAgaWYgKGV4dHJhQ2hlY2tzKSB7XG4gICAgZXh0cmFDaGVja3Mob3B0aW9ucyk7XG4gIH1cbiAgaWYgKGdldFRva2VuKSB7XG4gICAgb3B0aW9ucy50b2tlbiA9IGF3YWl0IGdldFRva2VuKHBhdGhuYW1lLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLy8gc3JjL211bHRpcGFydC9jb21wbGV0ZS50c1xuZnVuY3Rpb24gY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgcGFydHMsIG9wdGlvbnNJbnB1dCkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBjcmVhdGVQdXRPcHRpb25zKHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgb3B0aW9uczogb3B0aW9uc0lucHV0LFxuICAgICAgZXh0cmFDaGVja3MsXG4gICAgICBnZXRUb2tlblxuICAgIH0pO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVQdXRIZWFkZXJzKGFsbG93ZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgICAgdXBsb2FkSWQ6IG9wdGlvbnMudXBsb2FkSWQsXG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHBhcnRzXG4gICAgfSk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBwYXJ0cyxcbiAgaGVhZGVycyxcbiAgb3B0aW9uc1xufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICAgIGAvbXB1LyR7cGF0aG5hbWV9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJjb21wbGV0ZVwiLFxuICAgICAgICAgIFwieC1tcHUtdXBsb2FkLWlkXCI6IHVwbG9hZElkLFxuICAgICAgICAgIC8vIGtleSBjYW4gYmUgYW55IHV0ZjggY2hhcmFjdGVyIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGFzIEhUVFAgaGVhZGVycyBjYW4gb25seSBiZSB1cy1hc2NpaVxuICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMwI3N3ZWN0aW9uLTMuMi40XG4gICAgICAgICAgXCJ4LW1wdS1rZXlcIjogZW5jb2RlVVJJKGtleSlcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGFydHMpLFxuICAgICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBkZWJ1ZyhcIm1wdTogY29tcGxldGVcIiwgcmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLy8gc3JjL211bHRpcGFydC9jcmVhdGUudHNcbmZ1bmN0aW9uIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWQoXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWRcbiAgICB9O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKHBhdGhuYW1lLCBoZWFkZXJzLCBvcHRpb25zKSB7XG4gIGRlYnVnKFwibXB1OiBjcmVhdGVcIiwgXCJwYXRobmFtZTpcIiwgcGF0aG5hbWUpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICAgIGAvbXB1LyR7cGF0aG5hbWV9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJjcmVhdGVcIlxuICAgICAgICB9LFxuICAgICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBkZWJ1ZyhcIm1wdTogY3JlYXRlXCIsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChlcnJvci5tZXNzYWdlID09PSBcIkZhaWxlZCB0byBmZXRjaFwiIHx8IGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gc3JjL211bHRpcGFydC91cGxvYWQudHNcbmltcG9ydCBieXRlcyBmcm9tIFwiYnl0ZXNcIjtcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwidGhyb3R0bGVpdFwiO1xuZnVuY3Rpb24gY3JlYXRlVXBsb2FkUGFydE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBib2R5LCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLiBZb3Ugc2VudCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LCBkb3VibGUgY2hlY2sgd2hhdCB5b3UncmUgdHJ5aW5nIHRvIHVwbG9hZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHBhcnQ6IHsgYmxvYjogYm9keSwgcGFydE51bWJlcjogb3B0aW9ucy5wYXJ0TnVtYmVyIH0sXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBldGFnOiByZXN1bHQuZXRhZyxcbiAgICAgIHBhcnROdW1iZXI6IG9wdGlvbnMucGFydE51bWJlclxuICAgIH07XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRQYXJ0KHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIGhlYWRlcnMsXG4gIG9wdGlvbnMsXG4gIGludGVybmFsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpLFxuICBwYXJ0XG59KSB7XG4gIHZhciBfYTMsIF9iMiwgX2M7XG4gIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHJlcXVlc3RBcGkoXG4gICAgYC9tcHUvJHtwYXRobmFtZX1gLFxuICAgIHtcbiAgICAgIHNpZ25hbDogaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJ1cGxvYWRcIixcbiAgICAgICAgXCJ4LW1wdS1rZXlcIjogZW5jb2RlVVJJKGtleSksXG4gICAgICAgIFwieC1tcHUtdXBsb2FkLWlkXCI6IHVwbG9hZElkLFxuICAgICAgICBcIngtbXB1LXBhcnQtbnVtYmVyXCI6IHBhcnQucGFydE51bWJlci50b1N0cmluZygpXG4gICAgICB9LFxuICAgICAgLy8gd2VpcmQgdGhpbmdzIGJldHdlZW4gdW5kaWNpIHR5cGVzIGFuZCBuYXRpdmUgZmV0Y2ggdHlwZXNcbiAgICAgIGJvZHk6IHBhcnQuYmxvYlxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xuICBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG4gIGlmICgoX2EzID0gb3B0aW9ucy5hYm9ydFNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5hYm9ydGVkKSB7XG4gICAgaGFuZGxlQWJvcnQoKTtcbiAgfSBlbHNlIHtcbiAgICAoX2IyID0gb3B0aW9ucy5hYm9ydFNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgaGFuZGxlQWJvcnQpO1xuICB9XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VQcm9taXNlO1xuICAoX2MgPSBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGhhbmRsZUFib3J0KTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxudmFyIG1heENvbmN1cnJlbnRVcGxvYWRzID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IDYgOiA4O1xudmFyIHBhcnRTaXplSW5CeXRlcyA9IDggKiAxMDI0ICogMTAyNDtcbnZhciBtYXhCeXRlc0luTWVtb3J5ID0gbWF4Q29uY3VycmVudFVwbG9hZHMgKiBwYXJ0U2l6ZUluQnl0ZXMgKiAyO1xuZnVuY3Rpb24gdXBsb2FkQWxsUGFydHMoe1xuICB1cGxvYWRJZCxcbiAga2V5LFxuICBwYXRobmFtZSxcbiAgc3RyZWFtLFxuICBoZWFkZXJzLFxuICBvcHRpb25zLFxuICB0b3RhbFRvTG9hZFxufSkge1xuICBkZWJ1ZyhcIm1wdTogdXBsb2FkIGluaXRcIiwgXCJrZXk6XCIsIGtleSk7XG4gIGNvbnN0IGludGVybmFsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHBhcnRzVG9VcGxvYWQgPSBbXTtcbiAgICBjb25zdCBjb21wbGV0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgYWN0aXZlVXBsb2FkcyA9IDA7XG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgY3VycmVudFBhcnROdW1iZXIgPSAxO1xuICAgIGxldCByZWplY3RlZCA9IGZhbHNlO1xuICAgIGxldCBjdXJyZW50Qnl0ZXNJbk1lbW9yeSA9IDA7XG4gICAgbGV0IGRvbmVSZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IGJ5dGVzU2VudCA9IDA7XG4gICAgbGV0IGFycmF5QnVmZmVycyA9IFtdO1xuICAgIGxldCBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgbGV0IG9uVXBsb2FkUHJvZ3Jlc3M7XG4gICAgY29uc3QgdG90YWxMb2FkZWRQZXJQYXJ0TnVtYmVyID0ge307XG4gICAgaWYgKG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcykge1xuICAgICAgb25VcGxvYWRQcm9ncmVzcyA9IHRocm90dGxlKCgpID0+IHtcbiAgICAgICAgdmFyIF9hMztcbiAgICAgICAgY29uc3QgbG9hZGVkID0gT2JqZWN0LnZhbHVlcyh0b3RhbExvYWRlZFBlclBhcnROdW1iZXIpLnJlZHVjZShcbiAgICAgICAgICAoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyBjdXI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gdG90YWxUb0xvYWQgfHwgbG9hZGVkO1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gdG90YWxUb0xvYWQgPiAwID8gTnVtYmVyKCgobG9hZGVkIC8gdG90YWxUb0xvYWQgfHwgbG9hZGVkKSAqIDEwMCkudG9GaXhlZCgyKSkgOiAwO1xuICAgICAgICAoX2EzID0gb3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwob3B0aW9ucywgeyBsb2FkZWQsIHRvdGFsLCBwZXJjZW50YWdlIH0pO1xuICAgICAgfSwgMTUwKTtcbiAgICB9XG4gICAgcmVhZCgpLmNhdGNoKGNhbmNlbCk7XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgIGRlYnVnKFxuICAgICAgICBcIm1wdTogdXBsb2FkIHJlYWQgc3RhcnRcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzOlwiLFxuICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICBcImN1cnJlbnRCeXRlc0luTWVtb3J5OlwiLFxuICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgIGJ5dGVzKGJ5dGVzU2VudClcbiAgICAgICk7XG4gICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjdXJyZW50Qnl0ZXNJbk1lbW9yeSA8IG1heEJ5dGVzSW5NZW1vcnkgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgZG9uZVJlYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZGVidWcoXCJtcHU6IHVwbG9hZCByZWFkIGNvbnN1bWVkIHRoZSB3aG9sZSBzdHJlYW1cIik7XG4gICAgICAgICAgICBpZiAoYXJyYXlCdWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcGFydHNUb1VwbG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXJ0TnVtYmVyOiBjdXJyZW50UGFydE51bWJlcisrLFxuICAgICAgICAgICAgICAgIGJsb2I6IG5ldyBCbG9iKGFycmF5QnVmZmVycywge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBsZXQgdmFsdWVPZmZzZXQgPSAwO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZU9mZnNldCA8IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1BhcnRTaXplID0gcGFydFNpemVJbkJ5dGVzIC0gY3VycmVudFBhcnRCeXRlc1JlYWQ7XG4gICAgICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgdmFsdWVPZmZzZXQgKyByZW1haW5pbmdQYXJ0U2l6ZSxcbiAgICAgICAgICAgICAgdmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gdmFsdWUuc2xpY2UodmFsdWVPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVPZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcnRCeXRlc1JlYWQgPT09IHBhcnRTaXplSW5CeXRlcykge1xuICAgICAgICAgICAgICBwYXJ0c1RvVXBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IGN1cnJlbnRQYXJ0TnVtYmVyKyssXG4gICAgICAgICAgICAgICAgYmxvYjogbmV3IEJsb2IoYXJyYXlCdWZmZXJzLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFycmF5QnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgICBjdXJyZW50UGFydEJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICAgIHNlbmRQYXJ0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYW5jZWwoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJtcHU6IHVwbG9hZCByZWFkIGVuZFwiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2VuZFBhcnQocGFydCkge1xuICAgICAgYWN0aXZlVXBsb2FkcysrO1xuICAgICAgZGVidWcoXG4gICAgICAgIFwibXB1OiB1cGxvYWQgc2VuZCBwYXJ0IHN0YXJ0XCIsXG4gICAgICAgIFwicGFydE51bWJlcjpcIixcbiAgICAgICAgcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICBcInNpemU6XCIsXG4gICAgICAgIHBhcnQuYmxvYi5zaXplLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVwbG9hZFByb2dyZXNzRm9yUGFydCA9IG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcyA/IChldmVudCkgPT4ge1xuICAgICAgICAgIHRvdGFsTG9hZGVkUGVyUGFydE51bWJlcltwYXJ0LnBhcnROdW1iZXJdID0gZXZlbnQubG9hZGVkO1xuICAgICAgICAgIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICAgICAgICBvblVwbG9hZFByb2dyZXNzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICBjb25zdCBjb21wbGV0ZWRQYXJ0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICAgICAgdXBsb2FkSWQsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IHVwbG9hZFByb2dyZXNzRm9yUGFydFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIsXG4gICAgICAgICAgcGFydFxuICAgICAgICB9KTtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgXCJtcHU6IHVwbG9hZCBzZW5kIHBhcnQgZW5kXCIsXG4gICAgICAgICAgXCJwYXJ0TnVtYmVyOlwiLFxuICAgICAgICAgIHBhcnQucGFydE51bWJlcixcbiAgICAgICAgICBcImFjdGl2ZVVwbG9hZHNcIixcbiAgICAgICAgICBhY3RpdmVVcGxvYWRzLFxuICAgICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgICAgXCJieXRlc1NlbnQ6XCIsXG4gICAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgICApO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgcGFydE51bWJlcjogcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICAgIGV0YWc6IGNvbXBsZXRlZFBhcnQuZXRhZ1xuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudEJ5dGVzSW5NZW1vcnkgLT0gcGFydC5ibG9iLnNpemU7XG4gICAgICAgIGFjdGl2ZVVwbG9hZHMtLTtcbiAgICAgICAgYnl0ZXNTZW50ICs9IHBhcnQuYmxvYi5zaXplO1xuICAgICAgICBpZiAocGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2VuZFBhcnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbmVSZWFkaW5nKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZVVwbG9hZHMgPT09IDApIHtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgcmVzb2x2ZShjb21wbGV0ZWRQYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlYWRpbmcpIHtcbiAgICAgICAgICByZWFkKCkuY2F0Y2goY2FuY2VsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FuY2VsKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2VuZFBhcnRzKCkge1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlYnVnKFxuICAgICAgICBcInNlbmQgcGFydHNcIixcbiAgICAgICAgXCJhY3RpdmVVcGxvYWRzXCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwicGFydHNUb1VwbG9hZFwiLFxuICAgICAgICBwYXJ0c1RvVXBsb2FkLmxlbmd0aFxuICAgICAgKTtcbiAgICAgIHdoaWxlIChhY3RpdmVVcGxvYWRzIDwgbWF4Q29uY3VycmVudFVwbG9hZHMgJiYgcGFydHNUb1VwbG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcnRUb1NlbmQgPSBwYXJ0c1RvVXBsb2FkLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwYXJ0VG9TZW5kKSB7XG4gICAgICAgICAgdm9pZCBzZW5kUGFydChwYXJ0VG9TZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5jZWwoZXJyb3IpIHtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgKGVycm9yLm1lc3NhZ2UgPT09IFwiRmFpbGVkIHRvIGZldGNoXCIgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3B1dC50c1xuaW1wb3J0IHRocm90dGxlMiBmcm9tIFwidGhyb3R0bGVpdFwiO1xuXG4vLyBzcmMvbXVsdGlwYXJ0L3VuY29udHJvbGxlZC50c1xuYXN5bmMgZnVuY3Rpb24gdW5jb250cm9sbGVkTXVsdGlwYXJ0VXBsb2FkKHBhdGhuYW1lLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKSB7XG4gIGRlYnVnKFwibXB1OiBpbml0XCIsIFwicGF0aG5hbWU6XCIsIHBhdGhuYW1lLCBcImhlYWRlcnM6XCIsIGhlYWRlcnMpO1xuICBjb25zdCBvcHRpb25zV2l0aG91dE9uVXBsb2FkUHJvZ3Jlc3MgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBvblVwbG9hZFByb2dyZXNzOiB2b2lkIDBcbiAgfTtcbiAgY29uc3QgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWQoXG4gICAgcGF0aG5hbWUsXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zV2l0aG91dE9uVXBsb2FkUHJvZ3Jlc3NcbiAgKTtcbiAgY29uc3QgdG90YWxUb0xvYWQgPSBjb21wdXRlQm9keUxlbmd0aChib2R5KTtcbiAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdG9SZWFkYWJsZVN0cmVhbShib2R5KTtcbiAgY29uc3QgcGFydHMgPSBhd2FpdCB1cGxvYWRBbGxQYXJ0cyh7XG4gICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgIHBhdGhuYW1lLFxuICAgIHN0cmVhbSxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnMsXG4gICAgdG90YWxUb0xvYWRcbiAgfSk7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcnRzLFxuICAgIGhlYWRlcnMsXG4gICAgb3B0aW9uczogb3B0aW9uc1dpdGhvdXRPblVwbG9hZFByb2dyZXNzXG4gIH0pO1xuICByZXR1cm4gYmxvYjtcbn1cblxuLy8gc3JjL3B1dC50c1xuZnVuY3Rpb24gY3JlYXRlUHV0TWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnMsXG4gIGdldFRva2VuLFxuICBleHRyYUNoZWNrc1xufSkge1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcHV0KHBhdGhuYW1lLCBib2R5LCBvcHRpb25zSW5wdXQpIHtcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJib2R5IGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFpbk9iamVjdChib2R5KSkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJCb2R5IG11c3QgYmUgYSBzdHJpbmcsIGJ1ZmZlciBvciBzdHJlYW0uIFlvdSBzZW50IGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QsIGRvdWJsZSBjaGVjayB3aGF0IHlvdSdyZSB0cnlpbmcgdG8gdXBsb2FkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMubXVsdGlwYXJ0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdW5jb250cm9sbGVkTXVsdGlwYXJ0VXBsb2FkKHBhdGhuYW1lLCBib2R5LCBoZWFkZXJzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3Qgb25VcGxvYWRQcm9ncmVzcyA9IG9wdGlvbnMub25VcGxvYWRQcm9ncmVzcyA/IHRocm90dGxlMihvcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MsIDEwMCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgICAgYC8ke3BhdGhuYW1lfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBvblVwbG9hZFByb2dyZXNzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICBkb3dubG9hZFVybDogcmVzcG9uc2UuZG93bmxvYWRVcmwsXG4gICAgICBwYXRobmFtZTogcmVzcG9uc2UucGF0aG5hbWUsXG4gICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb246IHJlc3BvbnNlLmNvbnRlbnREaXNwb3NpdGlvblxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy9tdWx0aXBhcnQvY3JlYXRlLXVwbG9hZGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVNdWx0aXBhcnRVcGxvYWQoXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAgICBhc3luYyB1cGxvYWRQYXJ0KHBhcnROdW1iZXIsIGJvZHkpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICAgICAgXCJCb2R5IG11c3QgYmUgYSBzdHJpbmcsIGJ1ZmZlciBvciBzdHJlYW0uIFlvdSBzZW50IGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QsIGRvdWJsZSBjaGVjayB3aGF0IHlvdSdyZSB0cnlpbmcgdG8gdXBsb2FkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAgICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgcGFydDogeyBwYXJ0TnVtYmVyLCBibG9iOiBib2R5IH0sXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV0YWc6IHJlc3VsdC5ldGFnLFxuICAgICAgICAgIHBhcnROdW1iZXJcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBjb21wbGV0ZShwYXJ0cykge1xuICAgICAgICByZXR1cm4gY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgICAgICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICAgICAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cblxuLy8gc3JjL2NyZWF0ZS1mb2xkZXIudHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUZvbGRlcihwYXRobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHBhdGggPSBwYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyBwYXRobmFtZSA6IGAke3BhdGhuYW1lfS9gO1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmFkZFJhbmRvbVN1ZmZpeF0gPSBcIjBcIjtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgIGAvJHtwYXRofWAsXG4gICAge1xuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xuICByZXR1cm4ge1xuICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgIHBhdGhuYW1lOiByZXNwb25zZS5wYXRobmFtZVxuICB9O1xufVxuXG5leHBvcnQge1xuICBnZXRUb2tlbkZyb21PcHRpb25zT3JFbnYsXG4gIEJsb2JFcnJvcixcbiAgZ2V0RG93bmxvYWRVcmwsXG4gIGRpc2FsbG93ZWRQYXRobmFtZUNoYXJhY3RlcnMsXG4gIE1BWElNVU1fUEFUSE5BTUVfTEVOR1RILFxuICBCbG9iQWNjZXNzRXJyb3IsXG4gIEJsb2JDb250ZW50VHlwZU5vdEFsbG93ZWRFcnJvcixcbiAgQmxvYlBhdGhuYW1lTWlzbWF0Y2hFcnJvcixcbiAgQmxvYkNsaWVudFRva2VuRXhwaXJlZEVycm9yLFxuICBCbG9iRmlsZVRvb0xhcmdlRXJyb3IsXG4gIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTdG9yZVN1c3BlbmRlZEVycm9yLFxuICBCbG9iVW5rbm93bkVycm9yLFxuICBCbG9iTm90Rm91bmRFcnJvcixcbiAgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUsXG4gIEJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQsXG4gIEJsb2JSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICByZXF1ZXN0QXBpLFxuICBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVVcGxvYWRQYXJ0TWV0aG9kLFxuICBjcmVhdGVQdXRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kLFxuICBjcmVhdGVGb2xkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1LTjZXVDVHUC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@vercel/blob/dist/chunk-KN6WT5GP.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@vercel/blob/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobAccessError),\n/* harmony export */   BlobClientTokenExpiredError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobClientTokenExpiredError),\n/* harmony export */   BlobContentTypeNotAllowedError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobContentTypeNotAllowedError),\n/* harmony export */   BlobError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError),\n/* harmony export */   BlobFileTooLargeError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobFileTooLargeError),\n/* harmony export */   BlobNotFoundError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobNotFoundError),\n/* harmony export */   BlobPathnameMismatchError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobPathnameMismatchError),\n/* harmony export */   BlobRequestAbortedError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobRequestAbortedError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobServiceNotAvailable),\n/* harmony export */   BlobServiceRateLimited: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobServiceRateLimited),\n/* harmony export */   BlobStoreNotFoundError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobUnknownError),\n/* harmony export */   completeMultipartUpload: () => (/* binding */ completeMultipartUpload),\n/* harmony export */   copy: () => (/* binding */ copy),\n/* harmony export */   createFolder: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createFolder),\n/* harmony export */   createMultipartUpload: () => (/* binding */ createMultipartUpload),\n/* harmony export */   createMultipartUploader: () => (/* binding */ createMultipartUploader),\n/* harmony export */   del: () => (/* binding */ del),\n/* harmony export */   getDownloadUrl: () => (/* reexport safe */ _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.getDownloadUrl),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   list: () => (/* binding */ list),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   uploadPart: () => (/* binding */ uploadPart)\n/* harmony export */ });\n/* harmony import */ var _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-KN6WT5GP.js */ \"(action-browser)/./node_modules/@vercel/blob/dist/chunk-KN6WT5GP.js\");\n\n\n// src/del.ts\nasync function del(url, options) {\n  await (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    \"/delete\",\n    {\n      method: \"POST\",\n      headers: { \"content-type\": \"application/json\" },\n      body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n}\n\n// src/head.ts\nasync function head(url, options) {\n  const searchParams = new URLSearchParams({ url });\n  const response = await (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `?${searchParams.toString()}`,\n    // HEAD can't have body as a response, so we use GET\n    {\n      method: \"GET\",\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    size: response.size,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition,\n    cacheControl: response.cacheControl,\n    uploadedAt: new Date(response.uploadedAt)\n  };\n}\n\n// src/list.ts\nasync function list(options) {\n  var _a;\n  const searchParams = new URLSearchParams();\n  if (options == null ? void 0 : options.limit) {\n    searchParams.set(\"limit\", options.limit.toString());\n  }\n  if (options == null ? void 0 : options.prefix) {\n    searchParams.set(\"prefix\", options.prefix);\n  }\n  if (options == null ? void 0 : options.cursor) {\n    searchParams.set(\"cursor\", options.cursor);\n  }\n  if (options == null ? void 0 : options.mode) {\n    searchParams.set(\"mode\", options.mode);\n  }\n  const response = await (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `?${searchParams.toString()}`,\n    {\n      method: \"GET\",\n      signal: options == null ? void 0 : options.abortSignal\n    },\n    options\n  );\n  if ((options == null ? void 0 : options.mode) === \"folded\") {\n    return {\n      folders: (_a = response.folders) != null ? _a : [],\n      cursor: response.cursor,\n      hasMore: response.hasMore,\n      blobs: response.blobs.map(mapBlobResult)\n    };\n  }\n  return {\n    cursor: response.cursor,\n    hasMore: response.hasMore,\n    blobs: response.blobs.map(mapBlobResult)\n  };\n}\nfunction mapBlobResult(blobResult) {\n  return {\n    url: blobResult.url,\n    downloadUrl: blobResult.downloadUrl,\n    pathname: blobResult.pathname,\n    size: blobResult.size,\n    uploadedAt: new Date(blobResult.uploadedAt)\n  };\n}\n\n// src/copy.ts\nasync function copy(fromUrl, toPathname, options) {\n  if (!options) {\n    throw new _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError('access must be \"public\"');\n  }\n  if (toPathname.length > _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.MAXIMUM_PATHNAME_LENGTH) {\n    throw new _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\n      `pathname is too long, maximum length is ${_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.MAXIMUM_PATHNAME_LENGTH}`\n    );\n  }\n  for (const invalidCharacter of _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.disallowedPathnameCharacters) {\n    if (toPathname.includes(invalidCharacter)) {\n      throw new _chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`\n      );\n    }\n  }\n  const headers = {};\n  if (options.addRandomSuffix !== void 0) {\n    headers[\"x-add-random-suffix\"] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (options.contentType) {\n    headers[\"x-content-type\"] = options.contentType;\n  }\n  if (options.cacheControlMaxAge !== void 0) {\n    headers[\"x-cache-control-max-age\"] = options.cacheControlMaxAge.toString();\n  }\n  const response = await (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.requestApi)(\n    `/${toPathname}?fromUrl=${fromUrl}`,\n    {\n      method: \"PUT\",\n      headers,\n      signal: options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    downloadUrl: response.downloadUrl,\n    pathname: response.pathname,\n    contentType: response.contentType,\n    contentDisposition: response.contentDisposition\n  };\n}\n\n// src/index.ts\nvar put = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createPutMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar createMultipartUpload = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploadMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar createMultipartUploader = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createCreateMultipartUploaderMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar uploadPart = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createUploadPartMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\nvar completeMultipartUpload = (0,_chunk_KN6WT5GP_js__WEBPACK_IMPORTED_MODULE_0__.createCompleteMultipartUploadMethod)({\n  allowedOptions: [\"cacheControlMaxAge\", \"addRandomSuffix\", \"contentType\"]\n});\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdmVyY2VsL2Jsb2IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0I2Qjs7QUFFN0I7QUFDQTtBQUNBLFFBQVEsOERBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRCw2QkFBNkIsd0NBQXdDO0FBQ3JFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQseUJBQXlCLDhEQUFVO0FBQ25DLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUFVO0FBQ25DLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0EsMEJBQTBCLHVFQUF1QjtBQUNqRCxjQUFjLHlEQUFTO0FBQ3ZCLGlEQUFpRCx1RUFBdUIsQ0FBQztBQUN6RTtBQUNBO0FBQ0EsaUNBQWlDLDRFQUE0QjtBQUM3RDtBQUNBLGdCQUFnQix5REFBUztBQUN6QixvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhEQUFVO0FBQ25DLFFBQVEsV0FBVyxXQUFXLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG1FQUFlO0FBQ3pCO0FBQ0EsQ0FBQztBQUNELDRCQUE0QixxRkFBaUM7QUFDN0Q7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLHVGQUFtQztBQUNqRTtBQUNBLENBQUM7QUFDRCxpQkFBaUIsMEVBQXNCO0FBQ3ZDO0FBQ0EsQ0FBQztBQUNELDhCQUE4Qix1RkFBbUM7QUFDakU7QUFDQSxDQUFDO0FBMEJDO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcWWFzaXJcXE9uZURyaXZlXFxEZXNrdG9wXFwxLTggYWxleGlzXFxhbGV4aXMtYm9sdFxcbm9kZV9tb2R1bGVzXFxAdmVyY2VsXFxibG9iXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCbG9iQWNjZXNzRXJyb3IsXG4gIEJsb2JDbGllbnRUb2tlbkV4cGlyZWRFcnJvcixcbiAgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yLFxuICBCbG9iRXJyb3IsXG4gIEJsb2JGaWxlVG9vTGFyZ2VFcnJvcixcbiAgQmxvYk5vdEZvdW5kRXJyb3IsXG4gIEJsb2JQYXRobmFtZU1pc21hdGNoRXJyb3IsXG4gIEJsb2JSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSxcbiAgQmxvYlNlcnZpY2VSYXRlTGltaXRlZCxcbiAgQmxvYlN0b3JlTm90Rm91bmRFcnJvcixcbiAgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IsXG4gIEJsb2JVbmtub3duRXJyb3IsXG4gIE1BWElNVU1fUEFUSE5BTUVfTEVOR1RILFxuICBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCxcbiAgY3JlYXRlRm9sZGVyLFxuICBjcmVhdGVQdXRNZXRob2QsXG4gIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QsXG4gIGRpc2FsbG93ZWRQYXRobmFtZUNoYXJhY3RlcnMsXG4gIGdldERvd25sb2FkVXJsLFxuICByZXF1ZXN0QXBpXG59IGZyb20gXCIuL2NodW5rLUtONldUNUdQLmpzXCI7XG5cbi8vIHNyYy9kZWwudHNcbmFzeW5jIGZ1bmN0aW9uIGRlbCh1cmwsIG9wdGlvbnMpIHtcbiAgYXdhaXQgcmVxdWVzdEFwaShcbiAgICBcIi9kZWxldGVcIixcbiAgICB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1cmxzOiBBcnJheS5pc0FycmF5KHVybCkgPyB1cmwgOiBbdXJsXSB9KSxcbiAgICAgIHNpZ25hbDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xufVxuXG4vLyBzcmMvaGVhZC50c1xuYXN5bmMgZnVuY3Rpb24gaGVhZCh1cmwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHVybCB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgIGA/JHtzZWFyY2hQYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgIC8vIEhFQUQgY2FuJ3QgaGF2ZSBib2R5IGFzIGEgcmVzcG9uc2UsIHNvIHdlIHVzZSBHRVRcbiAgICB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBzaWduYWw6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICBkb3dubG9hZFVybDogcmVzcG9uc2UuZG93bmxvYWRVcmwsXG4gICAgcGF0aG5hbWU6IHJlc3BvbnNlLnBhdGhuYW1lLFxuICAgIHNpemU6IHJlc3BvbnNlLnNpemUsXG4gICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlLFxuICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcmVzcG9uc2UuY29udGVudERpc3Bvc2l0aW9uLFxuICAgIGNhY2hlQ29udHJvbDogcmVzcG9uc2UuY2FjaGVDb250cm9sLFxuICAgIHVwbG9hZGVkQXQ6IG5ldyBEYXRlKHJlc3BvbnNlLnVwbG9hZGVkQXQpXG4gIH07XG59XG5cbi8vIHNyYy9saXN0LnRzXG5hc3luYyBmdW5jdGlvbiBsaXN0KG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmxpbWl0KSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcImxpbWl0XCIsIG9wdGlvbnMubGltaXQudG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlZml4KSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcInByZWZpeFwiLCBvcHRpb25zLnByZWZpeCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY3Vyc29yKSB7XG4gICAgc2VhcmNoUGFyYW1zLnNldChcImN1cnNvclwiLCBvcHRpb25zLmN1cnNvcik7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZSkge1xuICAgIHNlYXJjaFBhcmFtcy5zZXQoXCJtb2RlXCIsIG9wdGlvbnMubW9kZSk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0QXBpKFxuICAgIGA/JHtzZWFyY2hQYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIHNpZ25hbDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xuICBpZiAoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZSkgPT09IFwiZm9sZGVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9sZGVyczogKF9hID0gcmVzcG9uc2UuZm9sZGVycykgIT0gbnVsbCA/IF9hIDogW10sXG4gICAgICBjdXJzb3I6IHJlc3BvbnNlLmN1cnNvcixcbiAgICAgIGhhc01vcmU6IHJlc3BvbnNlLmhhc01vcmUsXG4gICAgICBibG9iczogcmVzcG9uc2UuYmxvYnMubWFwKG1hcEJsb2JSZXN1bHQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGN1cnNvcjogcmVzcG9uc2UuY3Vyc29yLFxuICAgIGhhc01vcmU6IHJlc3BvbnNlLmhhc01vcmUsXG4gICAgYmxvYnM6IHJlc3BvbnNlLmJsb2JzLm1hcChtYXBCbG9iUmVzdWx0KVxuICB9O1xufVxuZnVuY3Rpb24gbWFwQmxvYlJlc3VsdChibG9iUmVzdWx0KSB7XG4gIHJldHVybiB7XG4gICAgdXJsOiBibG9iUmVzdWx0LnVybCxcbiAgICBkb3dubG9hZFVybDogYmxvYlJlc3VsdC5kb3dubG9hZFVybCxcbiAgICBwYXRobmFtZTogYmxvYlJlc3VsdC5wYXRobmFtZSxcbiAgICBzaXplOiBibG9iUmVzdWx0LnNpemUsXG4gICAgdXBsb2FkZWRBdDogbmV3IERhdGUoYmxvYlJlc3VsdC51cGxvYWRlZEF0KVxuICB9O1xufVxuXG4vLyBzcmMvY29weS50c1xuYXN5bmMgZnVuY3Rpb24gY29weShmcm9tVXJsLCB0b1BhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJtaXNzaW5nIG9wdGlvbnMsIHNlZSB1c2FnZVwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5hY2Nlc3MgIT09IFwicHVibGljXCIpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKCdhY2Nlc3MgbXVzdCBiZSBcInB1YmxpY1wiJyk7XG4gIH1cbiAgaWYgKHRvUGF0aG5hbWUubGVuZ3RoID4gTUFYSU1VTV9QQVRITkFNRV9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgYHBhdGhuYW1lIGlzIHRvbyBsb25nLCBtYXhpbXVtIGxlbmd0aCBpcyAke01BWElNVU1fUEFUSE5BTUVfTEVOR1RIfWBcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3QgaW52YWxpZENoYXJhY3RlciBvZiBkaXNhbGxvd2VkUGF0aG5hbWVDaGFyYWN0ZXJzKSB7XG4gICAgaWYgKHRvUGF0aG5hbWUuaW5jbHVkZXMoaW52YWxpZENoYXJhY3RlcikpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIGBwYXRobmFtZSBjYW5ub3QgY29udGFpbiBcIiR7aW52YWxpZENoYXJhY3Rlcn1cIiwgcGxlYXNlIGVuY29kZSBpdCBpZiBuZWVkZWRgXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmIChvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCAhPT0gdm9pZCAwKSB7XG4gICAgaGVhZGVyc1tcIngtYWRkLXJhbmRvbS1zdWZmaXhcIl0gPSBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCA/IFwiMVwiIDogXCIwXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY29udGVudFR5cGUpIHtcbiAgICBoZWFkZXJzW1wieC1jb250ZW50LXR5cGVcIl0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICB9XG4gIGlmIChvcHRpb25zLmNhY2hlQ29udHJvbE1heEFnZSAhPT0gdm9pZCAwKSB7XG4gICAgaGVhZGVyc1tcIngtY2FjaGUtY29udHJvbC1tYXgtYWdlXCJdID0gb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UudG9TdHJpbmcoKTtcbiAgfVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgYC8ke3RvUGF0aG5hbWV9P2Zyb21Vcmw9JHtmcm9tVXJsfWAsXG4gICAge1xuICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbFxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xuICByZXR1cm4ge1xuICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgIGRvd25sb2FkVXJsOiByZXNwb25zZS5kb3dubG9hZFVybCxcbiAgICBwYXRobmFtZTogcmVzcG9uc2UucGF0aG5hbWUsXG4gICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlLFxuICAgIGNvbnRlbnREaXNwb3NpdGlvbjogcmVzcG9uc2UuY29udGVudERpc3Bvc2l0aW9uXG4gIH07XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHB1dCA9IGNyZWF0ZVB1dE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIiwgXCJhZGRSYW5kb21TdWZmaXhcIiwgXCJjb250ZW50VHlwZVwiXVxufSk7XG52YXIgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkID0gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNhY2hlQ29udHJvbE1heEFnZVwiLCBcImFkZFJhbmRvbVN1ZmZpeFwiLCBcImNvbnRlbnRUeXBlXCJdXG59KTtcbnZhciBjcmVhdGVNdWx0aXBhcnRVcGxvYWRlciA9IGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZGVyTWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNhY2hlQ29udHJvbE1heEFnZVwiLCBcImFkZFJhbmRvbVN1ZmZpeFwiLCBcImNvbnRlbnRUeXBlXCJdXG59KTtcbnZhciB1cGxvYWRQYXJ0ID0gY3JlYXRlVXBsb2FkUGFydE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIiwgXCJhZGRSYW5kb21TdWZmaXhcIiwgXCJjb250ZW50VHlwZVwiXVxufSk7XG52YXIgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQgPSBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIiwgXCJhZGRSYW5kb21TdWZmaXhcIiwgXCJjb250ZW50VHlwZVwiXVxufSk7XG5leHBvcnQge1xuICBCbG9iQWNjZXNzRXJyb3IsXG4gIEJsb2JDbGllbnRUb2tlbkV4cGlyZWRFcnJvcixcbiAgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yLFxuICBCbG9iRXJyb3IsXG4gIEJsb2JGaWxlVG9vTGFyZ2VFcnJvcixcbiAgQmxvYk5vdEZvdW5kRXJyb3IsXG4gIEJsb2JQYXRobmFtZU1pc21hdGNoRXJyb3IsXG4gIEJsb2JSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBCbG9iU2VydmljZU5vdEF2YWlsYWJsZSxcbiAgQmxvYlNlcnZpY2VSYXRlTGltaXRlZCxcbiAgQmxvYlN0b3JlTm90Rm91bmRFcnJvcixcbiAgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IsXG4gIEJsb2JVbmtub3duRXJyb3IsXG4gIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkLFxuICBjb3B5LFxuICBjcmVhdGVGb2xkZXIsXG4gIGNyZWF0ZU11bHRpcGFydFVwbG9hZCxcbiAgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXIsXG4gIGRlbCxcbiAgZ2V0RG93bmxvYWRVcmwsXG4gIGhlYWQsXG4gIGxpc3QsXG4gIHB1dCxcbiAgdXBsb2FkUGFydFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@vercel/blob/dist/index.js\n");

/***/ })

};
;